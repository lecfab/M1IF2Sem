\documentclass{article}

\usepackage[english]{babel}

\usepackage{hyperref}
\usepackage{tikz}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{wasysym}


\newtheorem{proposition}{Proposition}
\newtheorem{claim}{Claim}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\theoremstyle{remark}
\newtheorem*{remark}{Remark}
\newtheorem*{example}{Example}

\newcommand{\Thm}[3]{\begin{theorem}[#1]\label{#2}#3\end{theorem}}
\newcommand{\Ex}[3]{\begin{example}[#1]\label{#2}#3\end{example}}
\newcommand{\Def}[3]{\begin{definition}[#1]\label{#2}#3\end{definition}}
\newcommand{\Lem}[3]{\begin{lemma}[#1]\label{#2}#3\end{lemma}}
\newcommand{\Cor}[3]{\begin{corollary}[#1]\label{#2}#3\end{corollary}}
\newcommand{\Prop}[3]{\begin{proposition}[#1]\label{#2}#3\end{proposition}}
\newcommand{\Rem}[3]{\begin{remark}[#1]\label{#2}#3\end{remark}}
\newcommand{\Proof}[1]{\begin{proof}#1\end{proof}}

\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\K}{\mathbb{K}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\C}{\mathcal{C}}
\newcommand{\X}{\mathcal{X}}

\newcommand{\hsp}{\hspace{20pt}}


\begin{document}
	
\title{Computational Complexity}
\author{Omar Fawzi, lecture notes by Enguerrand Prebet}

\maketitle
\tableofcontents

\section{Basic Questions}
\begin{itemize}
	\item Efficient verification vs Efficient computation (NP vs P)
	\item Power of randomness = P vs BPP
	\item Power of quantum systems = P vs BQP 
\end{itemize}

\subsection{Example frontier}
Circuit with AND, OR, NOT gates 
	MOD$_6$
	with CONSTANT depth and polynomial size
	
Show that SAT cannot be computed by such circuits

\underline{Algorithm:} Modeled by a Turing Machine (TM)

$M$ computes $f:\{0,1\}^* \rightarrow \{0,1\}^*$\\\\
Only one output tape\\
Run the machine $M$:\\
Apply transition function until reach $q_{halt}$

\begin{itemize}
	\item If never reach $q_{halt}$, $f$ undefined
	\item If reach $q_{halt}$ $f(x)$ = what it is written on the output tape
\end{itemize}
$M$ computes $f$ in time $T(n)$ if for all $x \in \{0,1\}^*$, $M$ on input $x$ halts after $T(|x|)$ steps\\\\
Church Turing thesis : Intuitive notion of algorithm = Turing machine\\

Important properties :
\begin{itemize}
	\item Turing machine can be represented by bitstrings. For $\alpha \in \{0,1\}^*$, $M_\alpha$ is the TM represented by $\alpha$
	\item Universal TM : There exists a TM $\mathcal{U} : \mathcal{U}(x,\alpha) = M_\alpha(x)$
\end{itemize}

\subsection{Complexity classes}
Conveniant to restrict to boolean function $f:\{0,1\}^*\rightarrow\{0,1\}$\\
Equivalently : $L = \{x \in \{0,1\}^* : f(x)=1\}$

\begin{definition}
	$L \in$ DTIME$(T(n))$ iff there exists a constant $c \rangle 0$ and a TM $M$ such that $M$ runs in time $cT(n)$ and compute $L$.
	
	P$ = \cup_{l \in \mathbb{N}} $DTIME$(n^l)$

\end{definition}

\begin{definition}[NP]
	$L \in$ NP if there exists $p$ polynomial and a polytime TM $M$ such that for every $x\in\{0,1\}^*$
		$x \in L \Leftrightarrow \exists u \in \{0,1\}^{p(|x|)}$ s.t $M(x,u) = 1$
		$u$ is called certificate, witness
\end{definition}

\subsection{Examples}
\begin{itemize}
	\item Any problem in P
	\item 3-COL = Set of graphs 3-colorable\\
	$x = \langle G\rangle$ (encoding of graph G)\\
	$u = \langle C\rangle$ with $C:V\rightarrow{1,2,3}$ a coloring\\
	$M$ verifies that $C$ is a valid function and that if $(v,w) \in E$, $C(v) \neq C(w)$
\end{itemize}
	Alternate def with nondet TM
\begin{definition}
	A k-tape nondeterministic TP (NDTM) is a $(\Gamma,Q,\delta)$
	$\Gamma$ alphabet
	Q state, $q_{start} \in Q$
	$q_{reject}$, $q_{accept}$
	$\delta$ can take multiple possible transitions
		$\delta_0, \delta_1 : Q\times\Gamma^k \rightarrow Q\times\Gamma^{k-1}\times{L,S,R}^k$
\end{definition}

\begin{definition}
	A path or execution of a NDTM is compatible with $\delta$ (at each step can choose $\delta_0$ or $\delta_1$)
	A path us accepting is the last state is $q_{accept}$
	An NDTM $N$ decides $L$ if $x\in L \Leftrightarrow \exists$ accepting path of $N$ on input $x$.
	The time taken by $N$ on input $x$ is the maximum over all paths.
	$N$ computes $L$ in $T(n)$ if for all inputs $x$, $N$ halts after $T(|x|)$ steps and $N$ decides $L$
\end{definition}

\begin{remark}
	Can also member nondeterministic TM as $N_\alpha$
\end{remark}

\begin{definition}
	NTIME$(T(n))$ is the set of languages $L$ s.t $\exists c \angle 0$ constant and $N$ running in time $cT(n)$ computes $L$.
\end{definition}

\begin{claim}
	NP $= \cup_{l\in \mathbb{N}^*}$ NTIME$(n^l)$
\end{claim}

\begin{proof}
	$L \in$ NTIME$(n^l)$. There exists $N$ with $k$ tapes that accepts $L$ in time $p(n)$.
	Want to construct DTM $M$ that takes input $(x,u)$ $(|u|=p(|x|))$
	$M$ has $k+1$ tapes.
	First step : Copy $u$ into tape 2.
	Second step $\delta(q,(\sigma_1,b,\sigma_2,...\sigma_k)) = \delta_b(q,(\sigma_1,...\sigma_k))$
															  and for tape 2 move to the right and keep symbol $b$.
	Final step
		Arrive at $q_{accept} \rightarrow$ write 1 on output tape and go to $q_{halt}$
				  $q_{reject} \rightarrow$ write 0 on output tape and go to $q_{halt}$
	
	If $N$ has an accepting path $\rightarrow \exists u$ s.t $M(x,u) = 1$
	And if $M(x,u) = 1 \rightarrow$ there is an accepting path in $N$
	For the other direction
	NP $\subseteq \cup$ NTIME$(n^l)$
	similar idea
\end{proof}

\subsection{Comparison between languages}
\begin{definition}
	$A$ problem $B$ reduces to $A$ if there is a function $f:\{0,1\}^* \rightarrow \{0,1\}^*$ computable in polytime such that $\forall x \in \{0,1\}^* : x \in B \Leftrightarrow f(x) \in A$
This type of reduction is called Karp reduction or many-to-one and we write $B \leq_p A$
\end{definition}

Simple property : If $A \in$ NP and $B \leq_p A$, then $B \in$ NP
	$x \in B \Leftrightarrow f(x) \in A \Leftrightarrow \exists u \in \{0,1\}^{p|f(x)|} : M(f(x),u) = 1$
	But $|f(x)| \leq |x|^l$ for some $l$
	
\begin{definition}
	$A$ is NP-hard if for any $B \in NP, B \leq_p A$
	$A$ is NP-complete if $A$ is NP-hard and in NP
\end{definition}
\begin{proposition}
	$A = \{(\alpha,x,1^t) : N_\alpha(x) \text{ accepts in time} \leq t\}$ is NP-complete
\end{proposition}
\begin{proof}
	First $A \in$ NP. Simulate using a universal NDTM except stop after $t$ steps.
	Let $B \in$ NP. There exists $\alpha_0$ such that $N_{\alpha_0}$ decides $B$ in time $p(n)$
	Reduction : $f(x) = (\alpha_0,x,1^{p(|x|)})$
	we have $x \in B \Leftrightarrow f(x) \in A$
\end{proof}

\section{A natural NR complete problem : SAT}
\begin{definition}
	Boolean formula $\varphi$,
	a variable $x_i$
	If $\varphi_1(x_1,...,x_n), \varphi_2(x_1,...,x_n)$ formulas
	$\varphi_1(x_1,...,x_n) \wedge \varphi_2(x_1,...,x_n)$,
	$\varphi_1(x_1,...,x_n) \vee \varphi_2(x_1,...,x_n)$,
	$\neg \varphi_1(x_1,...,x_n)$ are formulas
	
	A formula $\varphi$ is satisfiable  if there exists $a_1...a_r$
	
	...(blank)...
	
	SAT $ = \{\langle\varphi\rangle : \varphi \text{ satisfiable formula}\}$
\end{definition}

\begin{theorem}[Cook-Levin]
	SAT is NP-complete
\end{theorem}
\begin{proof}
	$SAT \in$ NP is easy (certificate is the assignment)\\
	SAT is NP-hard\\
	Let $B \in$ NP, computed by a NDTM $N = (\Gamma, Q, \delta)$ with $k$ tapes in time $\leq T(n)$
	
	Objective :
		$x \rightarrow \varphi_x$
		
		$x \in B \Leftrightarrow \varphi_x$ satisfiable\\
		
	$\varphi_x$ should encode that $x$ is accepted by $N$.
	Variables of $\varphi_x$ : describe a sequence of configuration of $N$\\
	Constraints : enforce seq of config corresponds to a computation of $N$ on input $x$
	
	Since, the time is $\leq T(n)$, for each tape, we can only look at $T(n)$ positions.\\

	\underline{Variables:}\\
	For each $\gamma \in \Gamma$ and tape r
	\begin{itemize}
		\item $C^r_{\gamma,i,j} = 1$ if $\gamma$ is written on tape r at time j in position i
		\item $P^r_{i,j} = 1$ if at time j the head of tape r is at position i
		\item $e_{q,j} = 1$ if at time j, the state is q
	\end{itemize}
	Number of variables: $(T(n)+1)^2 |\Gamma| k + (T(n)+1)^2 k + (T(n)+1)^2 |Q|$ = polynomial in n.\\
	
	\underline{Constraints}
	\begin{itemize}
		\item coherence (variables correspond to valid config)
		\begin{enumerate}
			\item Exactly one symbol per cell
			\item Head is at exactly one position for each time step
			\item One state for each time step
		\end{enumerate}
		\item initial x : initial config is correct
		\begin{enumerate}
			\item Initial state = q$_{\text{start}}$
			\item Heads at the beginning
			\item x written on Tape 1 at time 0
			\item Other tapes are empty
		\end{enumerate}
		\item transition$_j$ : j-th transition is valid.
		\begin{enumerate}
			\item heads moved correctly and symbols correct
			\item No changes for other cells
		\end{enumerate}
		\item Reach an accepting state
	\end{itemize}
	
	\underline{Coherence}
	\begin{enumerate}
		\item $\bigwedge\limits_{i,j,r}\bigvee\limits_{\gamma \in \Gamma}(C^r_{\gamma,i,j}\wedge\bigwedge\limits_{\gamma' \neq \gamma}(\neg C^r_{\gamma',i,j}))$
		\item $\bigwedge\limits_{j,r}\bigvee\limits_{i}(P^r_{i,j}\wedge\bigwedge\limits_{i' \neq i}(\neg P^r_{i',j}))$
		\item Same idea
	\end{enumerate}
	
	\underline{Initialize}
	\begin{enumerate}
		\item $e_{q_{\text{start}},0}$
		\item $\bigwedge\limits_r P^r_{0,0}$
		\item $\bigwedge\limits_{i=1}^{n}(C^1_{x_i,i,0})\bigwedge\limits_{i>n} C^1_{\Square,i,0} \wedge C^1_{\rhd,0,0}$
		\item $\bigwedge\limits_{r>1} C^r_{\rhd,0,0} \wedge \bigwedge\limits_i C^r_{\Square,i,0}$
	\end{enumerate}
	
	\underline{Transition$_j$}
	
	$j-1 \rightarrow j$\\
	$\delta_0(q,\gamma_{1,\dots,k}) = (q_0,\gamma^0_{1,\dots,k},d_0)$\\
	$\delta_1(q,\gamma_{1,\dots,k}) = (q_1,\gamma^1_{1,\dots,k},d_1)$
	
	Here $\gamma$ considered as a vector of symbols (for the k tape), the NDTM has exactly two transtions for each configuration, $d_i \in \{-1,0,1\}$ (direction in the tape)\\
	
	\underline{Notation}
	"$\varphi_1 \implies \varphi_2" = \neg \varphi_1 \vee \varphi_2$\\
	
	\begin{enumerate}
		\item $\bigwedge\limits_{i_1,\dots,i_k,\gamma_1,\dots,\gamma_k,q}(e_{q,j-1}\wedge\bigwedge\limits_r P^r_{i_r,j-1} \wedge C^r_{\gamma_r,i_r,j-1}) \implies ((e_{q_0,j}\wedge\bigwedge\limits_r P^r_{i_r+d_0,j}\wedge C^r_{\gamma^0_r,i_r,j})\vee(e_{q_1,j}\wedge\bigwedge\limits_r P^r_{i_r+d_1,j}\wedge C^r_{\gamma^1_r,i_r,j})$
		\item $\neg P^r_{i,j-1} \implies (\bigwedge\limits_{\gamma}(C^r_{\gamma,i,j-1} \Longleftrightarrow C^r_{\gamma,i,j}))$
	\end{enumerate}
	
	\underline{accept}\\
	$e_{q_{\text{accept}},T(|x|)}\\
	\varphi_x = \text{coherence} \wedge \text{initial}_x \wedge \bigwedge\limits_{j=1}^{T(|x|)-1} \text{transition}_j\wedge\text{accept}$\\
	
	$\varphi_x$ can be computed in time polynomial in $|x|$\\
	N(x) has accepting path $\Longleftrightarrow x \in B$
	
	$\Updownarrow$\\
	$\varphi_x$ is satisfiable.\\
	
	So B $\leq_p$ SAT.
\end{proof}

\Rem{}{arg2}{It is possible to have $\varphi_x$ be of size O(T log T)}

\begin{claim}
	C NP-complete and C $\leq_p$ A then A is NP-hard
\end{claim}

CNF formula (Conjonctive normal form)
\begin{itemize}
	\item Literal: $x_i$ or $\neg x_i$
	\item Clause: $\bigvee\limits_{j} l_j$
	\item CNF: $\varphi = \bigwedge\limits_i C_i$ where $C_i$ clause
	\item kCNF : clauses have $\leq$ k variables
\end{itemize}

\Def{3SAT}{}{input: 3CNF $\varphi$\\
	output: Is $\varphi$ satisfiable ?}

\Thm{}{}{3SAT is NP-complete}
Sufficient to show that SAT $\leq_p$ 3SAT

\Rem{}{}{2SAT $\in$ P}

\Def{coNP}{}{coNP $= \{L:L^c \in \text{NP}\}$, L $\in \{0,1\}^*$}

\Def{other def}{}{$L \in$ coNP If there exists a poly P and a polytime M\\
	$x \in L \Longleftrightarrow \forall u\in\{0,1\}^{p(|x|)} M(x,u) = 1$}

\Ex{}{}{P $\subseteq$ coNP}

Is SAT $\in$ coNP ?\\
If yes, then coNP = NP
\Proof{Let A $\in$ NP so A$\leq_p$ SAT\\
	$x \in A \Longleftrightarrow f(x) \in SAT \Longleftrightarrow \forall u \in\{0,1\}^{p(|x|)} M(f(x),u) = 1$\\
so A $\in$ coNP,
so NP $\subseteq$ coNP.\\
L $\in$ coNP $\implies$ L$^c$ $\in$ NP $\implies$ L$^c$ $\in$ coNP $\implies$ L $\in$ NP\\
So NP = coNP.}

But TAUTOLOGY $\in$ coNP.\\

\begin{claim}
	NP $\subseteq$ EXP\\
	coNP $\subseteq$ EXP\\
	EXP = $\bigcup\limits_{l>0} DTIME(2^{n^l})$
\end{claim}
\Proof{L $\in$ NP $\implies \exists$ p(n), M polytime on input x.\\
	New TM M' :
	
	\begin{enumerate}
		\item u $\in \{0,1\}^{p(|x|)}$
		\item For each u, run M on (x,u), if accepts $\implies$ accept
		\item At the end, reject
	\end{enumerate}

	M' runs in time 2$^{\text{poly}(n)}$ and M'(x) accepts $\Longleftrightarrow \exists u \in \{0,1\}^{p(|x|)}:M(x,u) = 1$}

Similar argument for coNP.\\

P $\neq$ EXP (Time hierarchy theorem)
\Thm{}{}{Let f: $\N \rightarrow \N^*$, g: $\N \rightarrow \N^*$ be time-constructible and f log f = o(g) then DTIME(f) $\subsetneq$ DTIME(g)}

\Rem{}{}{\begin{itemize}
		\item Ex: f(n) = n, g(n) = n$^2$\\
		DTIME(n) $\subsetneq$ DTIME(n$^2$)\\
		P $\subseteq$ DTIME(2$^n$) $\subsetneq$ DTIME(2$^{2n}$) $\subseteq$ EXP
		\item Definition: T is time constructible if there exists a constant c and a TM M that on input 1$^n$ outputs 1$^{T(n)}$ in time $\leq$ cT(n)\\
		Ex: T(n) = c, T(n) = n$^c$ are time constructible
	\end{itemize}}
\Proof{Diagonalization
	
	Define the machine V: input($\alpha$,x) n = $|(\alpha,x)|$
	\begin{enumerate}
		\item Compute g(n)
		\item run $\mathcal{U}$($\alpha$,($\alpha$,x)) for g(n) steps
		\item if computation finished output $\neg\mathcal{U}(\alpha,(\alpha,x))$\\
		Otherwise reject.
	\end{enumerate}
	V runs in time O(g(n))
	Now want to show that no machine M such that M($\alpha$,($\alpha$,x)) = V(($\alpha$,x)) $\forall\alpha,x$ runs in time $\leq$ cf(n)
	Let M$_{\alpha_0}$ be a machine that runs in time $\leq$ cf(n)\\
	From the universal TM theorem, there is a constant C$_{\alpha_0}$ such that for all y\\
	$\mathcal{U}(\alpha_0,y)$ stops after C$_{\alpha_0}$(1+cf($|y|$)log(f($|y|$))
	If $|y|$ is large enough, $\leq$ g($|y|$)
	Set y = ($\alpha_0$,x). So $\mathcal{U}$ on imput ($\alpha_0$,($\alpha_0$,x)) stops after $\leq$ g($|(\alpha_0,x)|$) for large enough $|x|$
	V(($\alpha_0$,x)) = $\neg\mathcal{U}$($\alpha_0$,($\alpha_0$,x)) = $\neg$M$_{\alpha_0}$($\alpha_0$,x)
	So M$_{\alpha_0}$ cannot compute the same langage as V. $\implies$ The language computed by V is not in DTIME(f)}

\subsection{SPACE Complexity}
\Rem{Important}{}{Input tape is in read only, output tape is write only, we count the cells only used on work tapes}

\Def{}{}{M works in space S(n) if it stops on all inputs x and uses $\leq$ cS($|x|$) cells of the worktapes (i.e visited by head)
	\begin{itemize}
		\item SPACE(S(n))
		\item DSPACE(S(n))
	\end{itemize}
	 is the set of languages decided by a TM in space S(n)}

\Def{}{}{L = DSPACE(log n)\\
	PSPACE = $\bigcup\limits_{c>0}$DSPACE$(n^c$)}

\Ex{}{}{~\\\begin{itemize}
		\item Can add two numbers in logspace
		\item SAT $\in$ PSPACE, so NP $\subseteq$ PSPACE
	\end{itemize}}
	
\Def{}{}{NSPACE(S(n)) is the set of languages decided by a non det TM in space S(n)}

\Def{}{}{NL = NSPACE(log n)\\
	NPSPACE = $\bigcup\limits_{c>0}$NSPACE$(n^c$)\\
	L $\subseteq$ NL, PSPACE $\subseteq$ NPSPACE}

\Thm{Space hierarchy theorem}{}{If f and g are space constructible (on input 1$^n$, compute 1$^{S(n)}$ in space O(S(n)) and f = o(g)\\
DSPACE(f(n)) $\subseteq$ DSPACE(g(n))}

Comparaison with time classes:\\
Trivial : DTIME(f) $\subseteq$ DSPACE(f), NTIME(f) $\subseteq$ NSPACE(f)\\

Useful concept: configuration graph of M (or N) on input x\\

Configuration of N (or M):\begin{itemize}
	\item state
	\item position of head on input and work tapes
	\item contents of \textbf{work} tapes
\end{itemize}

Config graph of N on input x is a directed graph\\
Vertices = configurations (a priori infinite but we'll put a bound depends on $|x|$)\\
Edges := $c_1 \rightarrow c_2$ if this transition can happen during the computation of N on x.\\

\Rem{}{}{Configuration + input:\begin{itemize}
		\item deterministic TM $\implies$ one outgoing edge
		\item NDTM $\implies$ two outgoing edge
	\end{itemize}}
	
\begin{claim}
	If a TM N works in space S(n) $\geq$ log n, the configuration graph of N on input x has at most $2^{cS(|x|)}$ vertices for constant c.
\end{claim}

\Proof{\#config: $|Q|.|x|.(cS(|x|)^{k-1}.|\Gamma|^{cS(|x|)(k-1)}) \leq 2^{cS(|x|)}$}
	
\Thm{}{}{For any S(n), with S(n) $\geq$ log n, NSPACE(S(n)) $\subseteq$ DTIME($2^{O(S(n))})$\\
	For any A $\in$ NSPACE(S(n)), there exists a constant c such that A $\in$ DTIME($2^{c(S(n))}$)}

\Proof{A decided by N $\rightarrow$ configuration graph G$_{N,x}$ with $\leq 2^{cS(n)}$ vertices\\
	M constructs $G_{N,x}$ explicitly\\
	N(x) accepts iff there is a path in $G_{N,x}$ from initial config and ends in accepting config.\\
	M performs BFS to look for this path.}

\Ex{}{}{Show that NTIME(T(n)) $\subseteq$ DPSACE(T(n)) }

\subsection{Complete problem}
\Def{}{}{A language B is PSPACE-hard if for any A$\in$ PSPACE, $A \leq_p B$ PSPACE-complete if B $\in$ PSPACE}
$\rightarrow$ Generalization of SAT
\Def{}{}{A quantified boolean formula (QBF) is of the form: $Q_1x_1Q_2x_2...Q_nx_n\varphi(x_1,...,x_n$)\\
$Q_i \in \{\forall,\exists\}$ $\varphi$ formula, $x_i \in \{0,1\}$}
Language TQBF is the set of QBF that evaluate to true

\Ex{}{}{$\exists x_1\exists x_2\exists x_n \varphi(x_1,...,x_n) \leftrightarrow \varphi$ satisfiable\\
	$\forall x_1,\forall x_2,...\forall x_n, \varphi(x_1,...,x_n) \leftrightarrow \varphi$ tautology\\
	
	If $\exists\forall\exists\forall$ captures existence of winning strategy in a two player game (??)}

\Thm{}{}{TQBF is PSPACE-complete}
\Proof{~\\
\begin{itemize}
		\item TQBF $\in$ PSPACE
		\begin{itemize}
		\item QBF-rec ($\Psi$)
		\begin{itemize}
			\item If $\Psi$ has no quantifier, accept if $\Psi$ true
			\item If $\Psi = \exists x \Psi'(x)$ return QBF-rec($\Psi'(0))\vee$QBF-rec$(\Psi'(1))$
			\item If $\Psi = \forall x \Psi'(x)$ return QBF-rec($\Psi'(0))\wedge$QBF-rec$(\Psi'(1))$
		\end{itemize}
		\item Key point: can re-use space can keep only the answer of QBF-rec($\Psi'(0)$)
		
		Space used:
		\begin{itemize}
			\item If $\Psi$ has no quantifiers: Space used = $O(\Psi)$
			\item If $\Psi$ has a quantifier : have to keep $\Psi$ Space($\Psi$) = O($|\Psi|$) + max(space($\Psi'(0)$),space($\Psi'(1)$))
		\end{itemize}

		We have at most $|\Psi|$ recursive calls Space($\Psi$) = O($|\Psi|^2$)\\

		So TQBF $\in$ PSPACE\\
	\end{itemize}

\item TQBF is PSPACE-hard (sketch)\\
A $\in$ PSPACE M decides A in space S(n)\\
Objective: A$\leq_p$TQBF\\
x $\mapsto \Psi_x$\\
Use configuration graph G$_{M,x}$
M accepts $\leftrightarrow$ there exists a path in G$_{M,x}$ from c$_0$ to accepting config
\end{itemize}}

\Rem{}{}{\#vertices in G$_{M,x}$ is $2^{O(S(n))} \rightarrow$ cannot have a variable for each vertex}
	
Variable in formula:
	Configuration variable = a set of variables, an assignment corresponds to a config
	\begin{itemize}
		\item $e_q \in \{0,1\}$ is state of machine q
		\item is head at position i on tape r
		\item $c_i^r$ value of tape r at postion i (alphabet for work tape is \{0,1\})
	\end{itemize}
	
\Proof{~\\
\begin{itemize}
	\item TQBF is PSPACE-hard (real),\\ A $\in$ PSPACE A computed by M with space S(n)\\
	Objective: $x \mapsto \Psi^x$, $x \in A \Leftrightarrow \Psi^x$ is true\\\\
	Variables:\\
	Configuiration variable = $e_q, p_i^r, c_i^r$ for state, head, and symbol at position i, on tape r.\\
	We will construct $\Psi_0(u,v) =$ true if config variable u = config var v, or there is an edge from u to v in config graph $G_{M,x}$\\
	$\Psi_0(u,v) = ((e_1(u) = e_1(v)) \wedge (e_2(u) = e_2(v)) \wedge ...) \vee[\bigwedge\limits_{q,q' \in Q} \bigwedge\limits_{i_1 = 1}^{|x|} \bigwedge\limits_{i_2 = 1}^{S(|x|)} \bigwedge\limits_{\gamma_1,\gamma_2} ([e_q(u) \wedge p_{i_1}^1(u) \wedge p_{i_2}^2(u) \wedge (x_{i_1} = \gamma_1) \wedge (c_{i_2}^2 = \gamma_2)] \implies [e_{q'}(v)\wedge p_{i_1+D_1}^1(v)\wedge p_{i_2+D_2}^2(v)\wedge(c_{i_2}(v)=\gamma_2)])]$\\\\
	$x \in A \Leftrightarrow$ there is a path from $C_0$ (initial config) to an accepting one of length $2^{O(S(n))}$\\\\
	$\Psi_i(u,v) = $ true if there is a path from u to v of length $\leq 2^i$:\\
	$\Psi_{i+1}(u,v) = \exists w \Psi_i(u,w)\wedge\Psi_i(w,v)\\\\
	\Psi^x = \exists z ((e_{q_accept}(z) = 1 )\wedge \Psi_{cS(n)}(c_0,z))$\\
	
	We have that $\Psi^x$ true $\Leftrightarrow x \in A$. Problem : $|\Psi_i| = |\Psi_{i-1}| + |\Psi_{i-1}| + 1 \implies |\Psi_i| \geq 2^{cS(n)}$\\
	
	Trick: $\Psi_{i+1}(u,v) = \exists w \forall(z,y)((z=u)\wedge(y=w))\vee((z=w)\wedge(y=v)) \implies \Psi_i(z,y))$\\
	In this case: $|\Psi_i| = $ poly$(S(n))$. Moreover, $\Psi^x$ can be computed in polytime in $|x|$.
\end{itemize}
}
	
\Rem{}{}{If A$\in$NPSPACE instead: Only difference: config graph can have 2 outgoing edges $\rightarrow$ modify $\Psi_0$ slightly $\implies$ TQBF is NPSPACE-hard. So PSPACE = NPSPACE.}

More generally (Savitch theorem)
\Thm{Savitch}{}{For a space constructible S(n), NSPACE(S(n)) $\subseteq$ DSPACE(S(n)$^2$)}
\Proof{(sketch)\\
	A$\in$NSPACE(S(n))\\
	Config graph $G_{M,x}$ of size $2^{O(S(n))}$
	REACH?(u,v,i) (= yes if there is a path from u to v of length $\leq 2^i$)\\
		If i = 0, check u -> v\\
		For all w\\
			If(REACH?(v,w,i-1) and REACH?(w,v,i-1))\\
				Accept\\
		Reject\\\\
Space(i)$\leq$Space(i-1) + O(S(n)) (-> keep w)
Spcae(c(S(n))) = O(S(n)$^2$)
	}
	
\Rem{}{}{Time(i) $\leq$ Time(i-1)$\cdot2^{cS(n)}$\\
	Time(S(n))$\leq 2^{cS(n)^2} = N^{O(\log N)}$ if N = $2^{cS(n)}$}
	
Consequence:

NPSPACE = PSPACE. L $\subseteq$ NL $\subseteq$ DSPACE(log$^2$n)

\subsubsection{Class NL}
\Def{}{}{A language B is NL-hard if for any A $\in$ NL, A $\leq_L$ B (meaning there exists a function f computable in logspace such that $x\in A \Leftrightarrow f(x)\in B$}

PATH: Input: Directed graph G = (V,E) and s,t $\in$ V\\
Output: yes if path from s to t in G\\\\

\Thm{}{}{PATH is NL-complete}
\Proof{\begin{itemize}
		\item PATH$\in$NL $\rightarrow$ see tutorial
		\item PATH is NL-hard. $G_{N,x} = (N_x,E_x)$\\
		Let A $\in$ NL. There is a NDTM N in sapce O(log n). Let $G_{N,x}$ config graph. $x\in A \Leftrightarrow$ there is a path from $c_0$ to accepting config in $G_{N,x}$\\
		Reduction: construct a graph $G'_x = (V_x\cup\{t\},E_x\cup E'_x)$ with $E'_x = \{(z,t)|z$ accepting$\}$\\
		Clearly, $x\in A \Leftrightarrow G'_x$ has a path from $c_0$ to t.\\
		To construct $G'_x$ in logspace, write all possible u,v$\in \{0,1\}^{c\log(n)}$ and check whether there is a valid transition from u to v by simulating N.
	\end{itemize}}

Big questions: \begin{itemize}
	\item NP vs coNP
	\item NL vs coNL
	\item NPSPACE vs coNPSPACE
\end{itemize}
(coNL = \{A$|$there is a NDTM N in logspace, $x\in A \Leftrightarrow$ all path in N(x) accept\})\\

\Thm{}{}{NL = coNL}
\Proof{Suffices to show $\overline{\text{PATH}}\in$NL.\\
	
$\overline{\text{PATH}}$: input G (directed graph), s,t\\
Output: 1 if s and t are not connected, 0 otherwise.\\

\Lem{}{}{There exists a non deterministic N in logarithmic space on input (G,s) s.t:\begin{itemize}
		\item N(G,s) has at least one accepting path.
		\item Number of vertices accessible from s is written on output tape for all accepting path.
	\end{itemize}}
Alg:\begin{itemize}
	\item Apply lemma, let k = output tape
	\item $b \leftarrow 0, c \leftarrow 0$ (counter)
	\item For all vertice u\\
	\indent Choose non deterministically a path from s of length $|V|$\\
	\indent If reach u \{$c \leftarrow c+1,$ if u = t, $b \leftarrow 1$\}
	\item If b = 0 \& c = k accept, otherwise reject.
\end{itemize}

Suppose (G,s,t) $\in \overline{\text{PATH}}$, then there exists an accepting path with c = k, and we never set b to 1 so we accept.

Suppose (G,s,t)$\notin \overline{\text{PATH}}$, have to check that all path reject. If c < k, reject. If c = k, all vertices reachable from s are reached and so t is reached and b = 1. If both cases, reject.
}
\Proof{Proof sketch for Lemma\\
	Let $S_i = \{v_i$ accesible from s in less than i steps$\}$, $S_0 = \{s\}$\\
	Idea: Compute $|S_{i+1}| using |S_i|$ (trick is we don't need $S_i$ but only size)\\
	
	Step 1: Given $|S_i|$ and u, if u $\in S_i$, all accepting path write 1 on output tape, if not, all accepting path write 0 on output tape.
	\newpage
	Test(s,u,i,$|S_i|$)\\
	\indent $c \leftarrow 0,b \leftarrow 0\\
	\indent$ For all v\begin{itemize}
		\item Apply PATH(G,s,$v_i$)
		\item If accepts:\\
		\indent $c \leftarrow c+1\\
		\indent $if v = u, $b \leftarrow 1$
	\end{itemize}
	If c = $|S_i|$, accept and return b otherwise reject.\\
	
	Step 2: $|S_i| \rightarrow |S_{i+1}|$\\
	$k \leftarrow 0$\\
	For all u\\
	\indent $b'\leftarrow0$\\
	\indent For all v\\
	\indent\indent b = Test(s,v,i,$|S_i|$)\\
	\indent\indent If accept and b = 1 and u = v or v $\rightarrow$\\
	\indent\indent\indent $b' \leftarrow 1$\\
	\indent $k \leftarrow k + b'$\\
	Return k
	}

\Thm{Immerman-Szelepcs\'enyi 87}{}{For any $S(n) \geq \log n$, and space constructible, coNSPACE(S(n)) = NSPACE(S(n))}
\Proof{Use "padding". Let A $\in$ coNSPACE(S(n)) decided by N, $A' = \{(x,1^{2^{S(|x|)}}):x\in A\}$\\
	$n = |x|\\
	m = |(x,1^{2^{S(|x|)}}) = |x| + 2^{S(|x|)} \leq 2\cdot2^{S(|x|)}\\
	\log m \leq S(n) + 1$\\
	Also $\log m \geq S(|x|)$
\begin{claim}
	A' $\in$ coNL
\end{claim}
\Proof{Algo: \begin{itemize}
		\item Check input has the form (x,$1^k)$
		\item Check that k = $2^{S(|x|)}$
		\item Run N on input x, uses space $S(|x|) = O(\log m)$
	\end{itemize}
	Use O(log m)\\
	But coNL = NL. So $A' \in NL$. So there is a non det machine N' in space O(log m) for A'\\
	
	NDTM for A. Input x\\
	Want to run N' on $(x,1^{2^{S(|x|)}})$ but cannot write that on a tape.\\
	Solution: extra tape that holds the position p of the head on $(x,1^{2^{S(|x|)}})$\\
	If $p \leq n$, read $x_p$, if $p > n$, read 1.
	}
}

\section{Oracles and the polynomial time hierarchy}
\Def{}{}{An Oracle Turing Machine is a TM with a special read/write tape and 3 special states: $q_{query},q_{yes},q_{no}$}

For $O\subseteq \{0,1\}*$ a language called oracle, we define $M^O$ that works as follows for any x:\begin{itemize}
	\item When $M^O$ enters state $q_{query}$ and $u \in \{0,1\}*$ is written on oracle tape, then next state is \begin{itemize}
			\item $q_{yes}$ if $u \in O$
			\item $q_{no}$ if $i \notin O$
		\end{itemize}
		and everything else is the same
\end{itemize}

\Rem{}{}{\begin{itemize}
		\item It costs one step to determine $u \in O$, or $u \notin O$
		\item x accepted if $M^O(x)$ arrives accepting state
		\item x accepted if $N^O(x)$ has an accepting path
	\end{itemize}}
	
\Def{}{}{$P^O$ is the set of languages that can be decided by a polytime deterministic machine with access to O\\
	NP$^O$\indent"\indent"\indent NDTM\indent".}

\Ex{}{}{if $O \in P$, $P^O = P$\\
	$P^{\text{SAT}}$ contains NP but also $\overline{SAT}$ and hence coNP.
}
\Rem{}{}{Warning: notation misleading : not clear how to define $\mathcal{C}^O$ for any set of language $\mathcal{C}$}

\Rem{}{}{For a fixed O, we have a universal Turing machine with oracle access to O that can simulate any machine with oracle O. This implies that we have a similar time hierarchy theorem}

Structure of hierarchy theorem:\begin{itemize}
	\item Effective representation of TMs
	\item Ability to simulate with a small overhead.
\end{itemize}
Define $f(\alpha) \neq M_\alpha(\alpha)$ for all machine $\alpha$ that use ressource $\subseteq$.\\

Time hierarchy theorem holds for all oracles O.\\
$\rightarrow$ such a result is called "relativizing".

Question: P vs NP relativize ?
In other words, is the answer the same in all oracle worlds ?

\Thm{}{}{There exists A,B, such that $P^A = NP^A$ and $P^B \neq NP^B$}

\Rem{}{}{\begin{itemize}
		\item Any proff that P = NP or P $\neq$ NP has to be sensitive to whether we have an oracle or not. Proof should not relativize.
		\item P = NP $\implies P^O = NP^O$ is not clear. Could be that nondet doesn't help but if there is an oracle O, starts being helpful.
		\item "There is an oracle B relative to which P $\neq$ NP"
	\end{itemize}}

\end{document}
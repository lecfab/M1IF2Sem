%/!\ /!\ 
%
% PLEASE DO NOT EDIT THIS IF YOU CAME HERE BY MISTAKE !!!!
%

% RTFMN : https://tobi.oetiker.ch/lshort/lshort.pdf

\documentclass{article}
\usepackage{xspace}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{url}
\usepackage{amssymb}
\usepackage{algorithme}
\usepackage{mathrsfs}
\usepackage{amsfonts}
\usepackage{multicol}
\usepackage{stmaryrd}
\usepackage{tikz, pgf}
\usetikzlibrary{arrows,intersections}
\usepackage{libertine}
\usepackage[a4paper,left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage{dsfont}


\usepackage[linktocpage]{hyperref}

\setlength{\hoffset}{-18pt}         
\setlength{\oddsidemargin}{15pt} % Marge gauche sur pages impaires
\setlength{\evensidemargin}{15pt} % Marge gauche sur pages paires
\setlength{\marginparwidth}{0pt} % Largeur de note dans la marge
\setlength{\textwidth}{481pt} % Largeur de la zone de texte 
\setlength{\marginparsep}{7pt} % Séparation de la marge
\setlength{\topmargin}{0pt} % Pas de marge en haut
\setlength{\headheight}{13pt} % Haut de page
\setlength{\headsep}{10pt} % Entre le haut de page et le texte
\setlength{\footskip}{50pt} % Bas de page + séparation
\setlength{\textheight}{600pt} % Hauteur de la zone de texte 

%\setlength{\hoffset}{-18pt}         
%\setlength{\oddsidemargin}{15pt} % Marge gauche sur pages impaires
%\setlength{\evensidemargin}{15pt} % Marge gauche sur pages paires
%\setlength{\marginparwidth}{0pt} % Largeur de note dans la marge
%\setlength{\textwidth}{481pt} % Largeur de la zone de texte 
%\setlength{\marginparsep}{7pt} % Séparation de la marge
%\setlength{\topmargin}{0pt} % Pas de marge en haut
%\setlength{\headheight}{8pt} % Haut de page
%\setlength{\headsep}{0pt} % Entre le haut de page et le texte
%\setlength{\footskip}{15pt} % Bas de page + séparation
%\setlength{\textheight}{700pt} % Hauteur de la zone de texte 

%\newcommand{\ket}[1]{\ensuremath{|#1\rangle}\xspace}
%\newcommand{\bra}[1]{\ensuremath{\langle #1|}\xspace}

\newtheorem{thm}{Theorem}[section]
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{defi}[thm]{Definition}
\newtheorem{ex}[thm]{Example}

\newcommand{\Thm}[3]{\begin{thm}[#1]\label{#2}#3\end{thm}}
\newcommand{\Ex}[3]{\begin{ex}[#1]\label{#2}#3\end{ex}}
\newcommand{\Def}[3]{\begin{defi}[#1]\label{#2}#3\end{defi}}
\newcommand{\Lem}[3]{\begin{lem}[#1]\label{#2}#3\end{lem}}
\newcommand{\Cor}[3]{\begin{cor}[#1]\label{#2}#3\end{cor}}
\newcommand{\Prop}[3]{\begin{prop}[#1]\label{#2}#3\end{prop}}

\newcommand{\Rem}{\underline{Remark:}}
\newcommand{\Idea}{\underline{Idea:}}
\newcommand{\Question}{\underline{Question:}}

\newcommand{\hsp}{\hspace{20pt}}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\K}{\mathbb{K}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\C}{\mathcal{C}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\B}{\mathcal{B}}
\newcommand{\X}{\mathcal{X}}
\newcommand{\brakets}[1]{\langle#1\rangle}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\bit}{\{0,1\}}

\newcommand{\ind}[1]{\mathds{1}_{#1}}
\renewcommand{\epsilon}{\varepsilon}

\title{Cryptography}
\author{Benoit Libert et Damien Stehlé	}
\date{Spring 2017}



\begin{document}

\maketitle

\tableofcontents

\newpage

\section{Introduction}
Cryptography is the science of information security, not just encryption. In a sense it is not just Information Theory.

The most classical form of encryption must satisfy:
\begin{itemize}
\item a talk to $B$ iver a public channel
\item we don't eavesdropper C to understand the communication.
\end{itemize}

\Ex{}{}{Take a client and a server such that each of them have a Browser with 2 stages:
\begin{itemize}
\item 1: Handshake. They create a common session key, $K$
\item 2: Using $K$, they can encrypt and decrypt the communication.
\end{itemize}

We will see the first step later, and in the following we will shortly deal with the second.
}

We have to deal with:
\begin{itemize}
\item Secret key cryptography: $A$ and $B$ use the same secret key $K$ to communicate
\item Cryptography is not just an encryption:
\begin{itemize}
\item How $A$ can be sure je is really talking to $B$ (use of digital signatures)
\item How can they know the that the communication has not been modified ? (Question of integrity)
\item What if I don't want to reveal my identity ? (Anonymous communication)
\end{itemize} 
\item More complex primitives and properties:
\begin{itemize}
\item Digital cash: should be anonymous, infeasible to fake or duplicate
\item E-voting: $n$ voter choose candidates, majority wins but votes should be anonymous, it must impossible to vote twice, votes must be verified.
\end{itemize}
\end{itemize}

Cryptography is a science on its own. It has its own methodology. Basically, we can sum it up in this few steps:
\begin{itemize}
\item One defines what the protocol has to do
\item One defines the attacker's goal and power. The aim is to give a security model.
\item One describes a protocol realisation
\item One «proves» that, if an «efficient» attacker exists, then some hard problem can be solved (e.g. factoring, computing discrete logarithms).
\end{itemize}

Cryptography often plays with some hard problems. It is a kind of face of complexity theory. It always suppose that protocols' specifications and description are public, the adversary knows how the protocol works, only the key remains private (Kerckhoff's principle).

However cryptography has its limitations:
\begin{itemize}
\item it relies on algorithmic assumptions and does not ensure unconditional security.
\item does not protect against engineering bugs (FREAK attack (2015), attack intercepts https connections and forces client/server to use weak encryption, or LOGJAM attack (2015), client/server forced to use too short keys)
\item some attacks are out-of-model exists: side-channel information (e.g. power consumption may leak the key)
\item backdoors may be correctly introduced in cryptographic implementations
\item security threats may be unrelated to cryptography
\end{itemize}

\section{One-time pad and perfect security}
\Def{Encrytion Scheme}{def:encrysch}{An encryption scheme $(Keygen, Enc, Dec)$ operates over finite sets $(K,P,C)$ with:
\begin{itemize}
\item $Keygen$ chooses $k$ uniformly in $K$
\item $Enc : K\times P \rightarrow C$
\item $Dec : K\times C \rightarrow P$
\end{itemize}
such that $\forall m\in P, k\in K, Dec(k,Enc(k,m))=m$ and such there are PPT algorithms that compute each of those previous functions.
\begin{itemize}
\item $m$ and $k$ are independent random variables
\item $Enc$ may be probabilistic but $Dec$ is usually deterministic
\item We assume (in the following) that elements of $K,P,C$ have non-zero probabilities.
\end{itemize}}

\Def{Perfect security (Shannon, 1949)}{def:perfSec}{For any message distribution $\mathcal{M}$ over $P$, \[\forall \bar{m}\in P, \Pr_{m\hookrightarrow\mathcal{M}, k\hookrightarrow U(K)}(m=\bar{m}|Enc(k,m))\]}

\underline{Remark:} The intuition is that giving $E(k,m)$ does not leaks any information about $m$. Formally, $m$ and $Enc(k,m)$ are independent.

\Lem{Shannon}{}{Perfect security implies that $|K|\geq|P|$}
\begin{proof}
By contradiction assume $|K|<|P|$. Then define $P(\bar{c})=\{m\in P|\exists k\in K, m=Dec(k,\bar{c})\}$. Then $|P(\bar{c})\leq|K|$ since $\forall m\in P(\bar{c}),\exists k\in K, m=Dec(k,\bar{c})$.

Then by our assumption $P-P(\bar{c})\neq\emptyset$. Let $\bar{m}$ be in this set. Then $\Pr(m=\bar{m}|\bar{c}=Enc(k,m))=0\neq\Pr(m=\bar{m})$. That is a contradiction with perfect security (ck previous remark).
\end{proof}

\Def{One-time Pad (OPT), Vernam's cipher (patented in 1917)}{def:OTP}{We take $K=\{0,1\}^l=P=C$. $Enc(k,m) = m\oplus k$ and $Dec(k,c)=c\oplus k$}

\Thm{}{thm:OPTPerfect}{Vernam's cipher is perfectly secret}
\begin{proof}
Let $\bar{m}\in P, \bar{c}\in C$ arbitrary. If we have $\Pr(c=\bar{c}|m=\bar{m})=\Pr(c=\bar{c}))=\Pr(c=\bar{c})$ then by multiplying by $\frac{\Pr(m=\bar{m})}{\Pr(c=\bar{c})}$ we get the result. Then let's compute it:
\[\begin{array}{r c l}
\Pr(c=\bar{c}|m=\bar{m}) & = & \Pr(m\oplus k=\bar{c}|m=\bar{m})\\
&=&\Pr(\bar{m}\oplus k \bar{c})\\
&=&\frac{1}{2^l}
\end{array}\]
\[\begin{array}{r c l}
\Pr(c=\bar{c}) & = & \sum_{\bar{m}}\Pr(\bar{c}=\bar{c}|m=\bar{m})\Pr(\bar{m}=m)\\
&=&\frac{1}{2^l}\sum_{\bar{m}}\Pr(\bar{m}=m)\\
&=&\frac{1}{2^l}
\end{array}\]
\end{proof}

The major problems with that are:
\begin{itemize}
\item key is as long as the message
\item we cannot encrypt twice with the same key ($Enc=Dec$)
\item Assumes an unbounded adversary (too powerful)
\end{itemize}

\section{Pseudo-random generators (PRG) and stream ciphers}
\subsection{One-time pad and pseudo-randomness}
\underline{Idea:} use the OPT with pseudo-random bits rather than truly random ones.

\begin{itemize}
\item We want to use a PRG $G:\{0,1\}^s\rightarrow\{0,1\}^n$ with $n\gg s$
\item Input $k\in\{0,1\}^s$, called \underline{seed} and contains all the randomness
\item $G$ is computable in deterministic polynomial time
\item Tempting idea for encryption: $Enc(k,m) = m\oplus G(k)$ and $Dec(c,k) = c\oplus k$ ($m\in\{0,1\}^n$ is longer than $s$).
\end{itemize}
\underline{Question:} Perfect secrecy is impossible. Can we get computational security ?

\Def{Negligible function}{def:negligFunc}{$f:\N\rightarrow\R$ is negligible if $\forall c>0,\exists n_0\in\N, \forall n>n_0,|f(n)|<n^{-c}$}

\Ex{}{}{$2^{-n}$, $n^{-\log n}$... are negligible functions of $n$.}

\Prop{}{}{For any negligible function $\epsilon$, for any polynomial $P$, the product $P(n)\epsilon(n)$ is still negligible}

\Def{Predictable PRG}{def:predPRG}{
A PRG is \underline{predictable} if there exists a PPT (Proba Poly Time) algorithm $A$ and an index $i\in\llbracket1,m\rrbracket$ such that:
\[\Pr_{k\hookrightarrow U(\{0,1\}^s), \text{$A$'s internal randomness}}(A(G(k|[1...i])=G(k)[i+1])>\frac{1}{2}+\epsilon(s)\]
for some non-negligible function of $s$, $\epsilon>0$.}
\underline{Remark:} It restricts the adversary's power (otherwise $A$ could use all possible $k$) and the probability is taken over the uniform choice of $k$ and the internal randomness of $A$.

\underline{Remark: } A PRG is unpredictable if for all PPT algorithm and index, $\epsilon$ is negligible.

\underline{Question: } How to compute $p:=\Pr_{k\hookrightarrow U(\{0,1\}^s), \text{$A$'s internal randomness}}(A(G(k|[1...i])=G(k)[i+1])$ ? One way to do so is to proceed as the following algorithm:\\


\begin{algorithme}
$x::=0$\\
\ForFromTo{i}{1}{N}{choose $k$ uniformly at random\\
If $A(G(k|[1...i])=G(k)[i+1]$ increment $x$}
\Return{$x/N\approx p$}
\end{algorithme}

Using Hoeffding bound we get $\Pr(|x-pN|\geq t)\leq 2\exp(-2t^2/N)$, then $\Pr(|x-pN|\geq t'\sqrt{N})\leq 2\exp(-2t'^2)$ for any $t'$. Then we get $p$ with approximation $1\pm\frac{10}{\sqrt{N}}$ with $t'=10$.


\Def{Distinguishability}{def:disting}{Let $D_1$ and $D_2$ be two distributions. They are distinguishable if there is a PPT algorithm $\mathcal{A}:\{0,1\}^n\rightarrow\{0,1\}$ with support $\{0,1\}^n$ such that $Adv_\mathcal{A}(D_1,D_2) := |\Pr_{x\hookrightarrow D_1}(\mathcal{A}(x)=1)-\Pr_{x\hookrightarrow D_2}(\mathcal{A}(x)=1)|$ is non-negligible. Then $\mathcal{A}$ is a distinguisher for $D_1$ and $D_2$.}

$G(\{0,1\}^s)$ is a tiny subset of $\{0,1\}^n$ but we want it to looks uniform. We want it is indistinguishable from the uniform distribution.

\Def{Indistinguishability}{def:indisting}{$D_1$ and $D_2$ are indistinguishable if for any PPT $\mathcal{A}:\{0,1\}^n\rightarrow\{0,1\}$ $Adv_\mathcal{A}(D_1,D_2)$ is negligible.}

\Def{Indistinguishability from uniform}{def:unifPRG}{A PRG $G$ is indistinguishable from uniform if $D_1:=\{G(k)|k\hookrightarrow U(\{0,1\}^s)\}$ and $D_2:=\{x|x\hookrightarrow U(\{0,1\}^n)\}$ are indistinguishable} 

\Def{unpredicatable PRG}{def:unpredPRG}{A PRG $G$ is unpredictable if dor evry PPT algorithm $\A$ and every $i\in\{1,...,n\}$,
\[|\Pr_{k\hookrightarrow U(\{0,1\}^s)}(\A(G(k)[1...i])=G(k)[i+1])-\frac{1}{2}|\leq negl(s)\]
for some $negl:\N\rightarrow\N$.
}

\Rem Statistical distinguishers always exist. A random $x\hookrightarrow U(\{0,1\}^n)$ belongs to $G(\{0,1\}^s)$ with proba $\frac{1}{2^{n-s}}$. Distinguisher can try all possible $k\in\{0,1\}^s$ (we just hope it is to costly).

\Thm{}{thm:indisUnpredEquiv}{Definition \ref{def:unpredPRG} and \ref{def:unifPRG} are equivalent.}

\begin{proof}
\begin{itemize}
\item Easy part: if there is a predictor, there is a distinguisher. Let $i\in\{1,..,n\}$ and a predictor $\A:\{0,1\}^i\rightarrow\{0,1\}$ running in PPT such that 
\[\Pr_k(\A(G(k)[1...i])=G(k)[i+1])>\frac{1}{2}+\epsilon\]
for some negligible $\epsilon>0$.

We build $\A':\{0,1\}^n\rightarrow\{0,1\}$ which, given $x=x_1$, $x_n\in\{0,1\}^n$ decides if $x=G(k)$ for some $k\in\{0,1\}^s$ or $x\hookrightarrow U(\{0,1\}^n)$. Define it as follows: $\A':x\mapsto\left\{\begin{array}{r l}
1 & \text{if $\A(x_1,...,x_n)=x_{i+1}$}\\
0 & \text{otherwise}
\end{array}\right.$
\[\begin{array}{r c l}
Adv_{\A'} &=& |\Pr_{k\hookrightarrow U(\{0,1\}^s)}(\A'(G(k))=1)-\Pr_{x\hookrightarrow U(\{0,1\}^n)}(\A'(x)=1)|\\
&=& |\Pr_k(\A(G(k)[1...i])=G(k)[i+1]) - \frac{1}{2}|\\
&=& |(\frac{1}{2}+\epsilon)-\frac{1}{2}|\\
&=& \epsilon
\end{array}\]
\item Here the harder part. We use an hybrid argument. Let $D_n=G(U(\{0,1\}^s))$ and $D_0=U(\{0,1\}^n)$. Let $\A$ be a PPT distinguisher such that $Adv_\A(D_n,D_0)\geq\epsilon$ for some non-negligible $\epsilon$. Let $D_i$ an hybrid distribution over $\{0,1\}^n$ where the first $i$ bits are those of $G(k)$ and that last $n-i$ bit are uniform, \[D_i=\{G(k)[1...i]||Y(\{0,1\}^{n-i})|k\hookrightarrow U(\{0,1\}^s)\}\]

By the triangle equality, there exists $i\in\{1...n\}$ such that $Adv_\A(D_i,D_{i+1})\geq\frac{\epsilon}{n}$. We build a predictor by choosing $i\hookrightarrow U(\{1...n\})$. $\A'$ takes input $(x_1...x_i)\in G(k)[1...i]\subseteq\{0,1\}^i$ and should find $G(k)[i+1]$ using $\A$.
$\A'$ chooses $x_{i+1}...x_n\hookrightarrow U(\{0,1\})$ and feed $\A$ with $x_1...x_n$.
\begin{itemize}
\item If $\A$ outputs $0$, it believes it sees $D_i$ meaning that $x_{i+1}\hookrightarrow U(\{0,1\})$ Then $\A'$ outputs $1-x_{i+1}$.
\item If $\A$ outputs $1$, it believes it sees $D_{i+1}$ meaning that $x_{i+1}=G(k)[i+1]$. Then $\A'$ outputs $x_{i+1}$.
\end{itemize}
We now want to compute $\Pr(\A'(G(k)[1...i])=G(k)[i+1])$.

Let us define $\overline{D_{i+1}}$ as $D_{i+1}$ where the $(i+1)^{th}$ bit is flipped. We interpret $D_i$ as the weighted sum of $D_{i+1}$ and $\overline{D_{i+1}}$. Then $\A'$ feeds $\A$ with $D_{i+1}$ or with $\overline{D_{i+1}}$ both with probability $\frac{1}{2}$.
\begin{itemize}
\item If $\A'$ feeds $\A$ with $D_{i+1}$, then $x_{i+1}=G(k)[i+1]$ and $\A'$ outputs $G(k)[i+1]$ iff $\A$ returns $1$.
\item If $\A'$ feeds $\A$ with $\overline{D_{i+1}}$, then $x_{i+1}=1-G(k)[i+1]$ and $\A'$ outputs $G(k)[i+1]$ iff $\A$ returns $0$.
\end{itemize}
Let $p=\Pr_k(\A'(G(k)[1...i])=G(k)[i+1])$
\[\begin{array}{r c l}
p &=& \Pr_{x\hookrightarrow D_i}((\A(x)=0\wedge x_{i+1}=1-G(k)[i+1])\vee(A(x)=1\wedge x_{i+1}=G(k)[i+1]))\\
&=& \Pr_{x\hookrightarrow D_i}(\A(x)=0\wedge x_{i+1}=1-G(k)[i+1])+\Pr_{x\hookrightarrow D_i}(A(x)=1\wedge x_{i+1}=G(k)[i+1])\\
&=& \Pr_{x\hookrightarrow D_i}(A(x)=0|x_{i+1}=1-G(k)[i+1])\Pr(x_{i+1}=1-G(k)[i+1])\\
&& +\Pr_{x\hookrightarrow D_i}(A(x)=1|x_{i=1}=G(k)[i+1])\Pr(x_{i+1}=G(k)[i+1]) \\
&=& \Pr_{x\hookrightarrow D_i}(A(x)=0|x_{i+1}=1-G(k)[i+1])\frac{1}{2} 	+\Pr_{x\hookrightarrow D_i}(A(x)=1|x_{i=1}=G(k)[i+1])\frac{1}{2}\\
&=& \frac{1}{2}(\Pr_{x\hookrightarrow D_{i+1}}(A(x)=1)+\Pr_{x\hookrightarrow\overline{D_{i+1}}}(A(x)=0))\\
&=& \frac{1}{2}(\Pr_{x\hookrightarrow D_{i+1}}(A(x)=1)+1-\Pr_{x\hookrightarrow\overline{D_{i+1}}}(A(x)=1))
\end{array}\]
Also $\Pr_{x\hookrightarrow D_i}(A(x)=1)=\frac{1}{2}(\Pr_{x\hookrightarrow D_{i+1}}(A(x)=1)+\Pr_{x\hookrightarrow\overline{D_{i+1}}}(A(x)=1))$. Then  $2\Pr_{x\hookrightarrow D_i}(A(x)=1)-(\Pr_{x\hookrightarrow D_{i+1}}(A(x)=1)=\Pr_{x\hookrightarrow\overline{D_{i+1}}}(A(x)=1)$. Then 
\[\begin{array}{r c l}
p &=& \frac{1}{2}(1+\Pr_{x\hookrightarrow D_{i+1}}(A(x)=1)+\Pr_{x\hookrightarrow D_{i+1}}(A(x)=1))-\Pr_{x\hookrightarrow D_i}(A(x)=1)\\
&=& \frac{1}{2} + \Pr_{x\hookrightarrow D_{i+1}}(A(x)=1)-\Pr_{x\hookrightarrow D_i}(A(x)=1)
\end{array}
\]
Then
\[\begin{array}{r c l}
Adv_{\A'} &=& |p-\frac{1}{2}|\\
&=& |\Pr_{x\hookrightarrow D_{i+1}}(A(x)=1)-\Pr_{x\hookrightarrow D_i}(A(x)=1)|\\
&=& \frac{\epsilon}{n}\\
&=& \frac{Adv_\A(D_{i+1},D_i)}{n}
\end{array}\]
\end{itemize}
\end{proof}
\subsection{Building and using PRGs is not trivial}
\begin{itemize}
\item Linear feedback shift registers (LFSRs) (used in GSM, CSS-DVD, blue-tooth) is very efficient in hardware (see TDs)
\item RC4 used in TLS now deemed too weak; statistical bias already in the first few bits.
\item eastream $\{0,1\}^s\times\{0,1\}^n\rightarrow\{0,1\}^n$ where second argument is a nonce used to randomize seed.
\end{itemize}
\paragraph{Using PRG encrypt is non-trivial} Double encryption is non secure. Let $c_1=Enc(k,m_1)=m_1\oplus G(k)$ and $c_2=Enc(k,m_2)=m_2\oplus G(k)$ then $c_1\oplus c_2 = m_1\oplus m_2$.
\underline{Other attempt:} WEP (Wired Equivalent Privacy) (used in IEEE 80211 norm to secure wifi networks replaced by WPA in 2003). $Enc(k,m)$ take short IV and compute $c=m\oplus PRG(IV||k)$. WEP128 takes 24 bits for IV and 104 for $k$ (the PRG has 128 bits seeds). Wery quickly all IVS have been used and the same ssed is used twice. Then successive IVs make seeds highly correlated.
\subsection{Encryption with semantic security}

\underline{Shanon (perfect security):} the distribution $Enc(k,m_0)$ and $Enc(k,m_1)$ shuold be identical for any $m_0,m_1$. Then $|k|=|m|$ ($|K|=|P|$), what is a too strong property.\\
\underline{Semantic security :} for one-time keys and chosen plain-text attacks. From a random $k\hookrightarrow U(K)$, $Enc(k,m_0)$ should be computationally indistinguishable from $Enc(k,m_1)$.

\Def{Semantically secureness}{def:semSecure}{An ecryption scheme $(Keygen,Enc,Dec)$ over $(K,l,C)$ is semantically secure if, for any PPT adversary $\A$, there exists a negligible function $negl:\N\rightarrow\N$ such that $Adv_\A(\lambda)\leq negl(\lambda)$.}

Consider the experiment $Exp_b$ where $b\in\{0,1\}$.
\begin{itemize}
\item $\A$ is given $A^\lambda$ and chooses messages $M_0,M_1$ of the same length
\item Challenger chooses a key $k\hookrightarrow Keygen(1^\lambda)$ and computes $c=Enc(k,M_b)$ which is given to $\A$.
\item $\A$ outputs $b'\in\{0,1\}$ and wins if $b=b'$. 
\end{itemize}
$Adv_\A=|\Pr(\A^{Exp_1}(1^\lambda)=1)-\Pr(\A^{Exp_0}(1^\lambda)=1)|$.

\begin{center}
\begin{tikzpicture}[>=latex]
\node	[]	at 	(0,6)	{Challenger};
\node	[]	at	(6,6)	{Adeversary};
\node	[]	at	(0,5)	{$b\hookrightarrow U(\{0,1\})$};
\node	[]	at	(0,4)	{$k\hookrightarrow Keygen(1^\lambda)$};
\node	[]	at	(0,1)	{Test if $b=b'$};

\draw	[->]	(1,4.5)	--node[above]	{$1^\lambda$}	(5,4.5);
\draw	[->]	(5,3.5)	--node[above]	{$M_0,M_1$}		(1,3.5);
\draw	[->]	(1,2.5)	--node[above]	{$c=Enc(k,M_b)$}	(5,2.5);
\draw	[->]	(5,1.5)	--node[above]	{$b'$}		(1,1.5);
\end{tikzpicture}
\end{center}

\Rem $Adv_\A=2|\Pr(b=b')-\frac{1}{2}|$.
\begin{itemize}
\item One time keys is a very important restriction
\item One time pad: $\Pr(\A(M_0\oplus k)=1)=\Pr(\A(M_1\oplus k)=1)$.
\end{itemize}

\paragraph{Secure PRG implies semantically secure encryption}
Let $G:\{0,1\}^s\rightarrow\{0,1\}^n$ be a PRG. Encrypt $M\in\{0,1\}^n$ using $k\in\{0,1\}^s$ as $c=M\oplus G(k)$.
Decrypt c as $M=c\oplus G(k)$.

\Thm{}{thm:securePRGSemSecEncryt}{If $G$ is a PRG, then $Enc(k,M)=M\oplus G(k)$ is a semantically secure encryption scheme : If there exists a PPT $\A$ with advantage $\epsilon$ against semantic security, there exists a PRG distinguisher $\mathcal{B}$ with advantage $\frac{\epsilon}{2}$.}

\Rem Then $Dec(k,c)=c\oplus G(k)$

\begin{proof} (reduction).
\paragraph{Idea of the proof} We suppose $\A$ and will build $\mathcal{B}$ against the PRG.
\begin{center}
\begin{tikzpicture}[>=latex]
\node	[]	at 	(0,6)	{PRG Challenger};
\node	[]	at	(6,6)	{Reducion $\mathcal{B}$};
\node	[]	at	(12,6.25)	{Adversary $\A$};
\node	[]	at	(12,5.75)	{against semantic security};

\draw	[-]		(3,0)	--								(3,1.4);
\draw	[-]		(3,2)	--								(3,4.4);
\draw	[-]		(3,5)	--								(3,7);
\draw	[-]		(9,0)	--								(9,1.4);
\draw	[-]		(9,4)	--								(9,7);
%\draw	[-]		(3,7)	--								(10,7);
%\draw	[-]		(3,5)	--								(10,5);			

\draw	[->]	(9.75,3.5)	--node[above]	{$M_0,M_1$}		(8.25,3.5);
\draw	[->]	(8.25,2.5)	--node[above]	{$c=Enc(k,M_b)$}	(9.75,2.5);
\draw	[->]	(9.75,1.5)	--node[above]	{$b'$}		(8.25,1.5);



\node	[]	at	(0,5.5)		{$b\in\{0,1\}$ uniform};
\node	[]	at	(0,5)	{if $b=0$ $x\hookrightarrow U(\{0,1\})$};
\node	[]	at	(0,4.5)	{else $x=G(k)$};
\node	[]	at	(0,4)	{with $k\hookrightarrow U(\{0,1\}^s)$};

\draw [->] (2.25,4.5) --node[above] {$x$} (3.75,4.5);
\draw [->] (3.75,1.5) --node[above] {$b'$} (2.25,1.5);
\end{tikzpicture}
\end{center}

$Exp_b$:
\begin{itemize}
\item $\A$ chooses $M_0,M_1\in\{0,1\}^n$
\item $\mathcal{B}$ chooses $k\hookrightarrow U(\{0,1\}^s)$ and gives $c=M_b\oplus G(k)$ to $\A$.
\item $\A$ outputs $b'$.
\end{itemize}

$Rand_b$:
\begin{itemize}
\item $\A$ chooses $M_0,M_1\in\{0,1\}^n$
\item $\mathcal{B}$ chooses $x\hookrightarrow U(\{0,1\}^n)$ and gives $c=M_b\oplus x$ to $\A$
\item $\A$ outputs $b'$
\end{itemize}

By hypothesis, $Adv_\A=|\Pr(A^{Exp_1}=1)-\Pr(\A^{Exp_0}=1)|\geq\epsilon$. Also $|\Pr(A^{Rand_1}=1)-\Pr(\A^{Rand_0}=1)|=0$. How does $\mathcal{B}$ works?
\begin{itemize}
\item $\mathcal{B}$ receives $x\in\{0,1\}^n$ and must decide if $x=G(k)$ or uniform.
\item When receiving $M_0,M_1$ form $\A$ it returns $c=M_b\oplus x$ for a random $b\hookrightarrow U(\{0,1\})$
\item Output $b'$
\end{itemize}
If $b'=b$, it outputs $1$ ($x=G(k)$) otherwise it outputs $0$ -$x$ uniform). In the first case it runs $Exp_1$ or $Exp_0$ with same proba. In the second, idem is the $Round$ experiments, that are the same from $\A$'s point of view.

\paragraph{The proof:} 
\begin{itemize}
\item In the uniform case for $x$. Then $c$ is uniformly distributed independently of $b$. Then $\Pr(\A=1|b=0)=\Pr(\A=0|b=1)$.
\item In the other case $x=G(k)$, $k$ uniform. When $b=0$ in $\A$'s view, we are in $Exp_0$, when $b=1$, we are in $Exp_1$.
\end{itemize}
Then \[\begin{array}{r c l}
Adv_\B &=&|\Pr_{Uniform}(\B=1)-\Pr_{G}(\B=1)|\\
&=& |\Pr_{Uniform}(b=b')-\Pr_{G}(b=b')|\\
&=& |\half-\half\Pr_G(b'=0|b=0)-\half\Pr_G(b'=1|b=1)|\\
&=& \half |1-\Pr_{Exp_0}(\A=0)-\Pr_{Exp_1}(\A=1)|\\
&=& \half |\Pr_{Exp_0}(\A=1)-\Pr_{Exp_1}(\A=1)|\\
&=& \half Adv_\A
\end{array}\].
Then if $\A$ efficient then $\B$ also what contradicts the PRG.
\end{proof}

\section{Block ciphers, PRFs}
The most used cryptographic primitive (symmetric encryption).

$Enc:\begin{array}{r c l}
\bit^{n'}\times\bit^n &\rightarrow&\bit^m\\
key,pleintext&\mapsto&ciphertext
\end{array}$ and $Dec:\begin{array}{r c l}
\bit^{n'}\times\bit^n &\rightarrow&\bit^m\\
key,ciphertext&\mapsto&pleintext
\end{array}$

\subsection{In pratice}
Woks with $k_1...k_n$ keys.
\subsubsection{Feistel networks; (common) design principle}
\begin{center}
\begin{tikzpicture}[>=latex]
\node at (0,8) {$M_L$ ($n/2$ bits)};
\node at (6,8) {$M_R$ ($n/2$ bits)};
\node at (3,7) {$F_{k_1}(\cdot)$};
\node at (0,7) {$\oplus$};
\node at (3,5) {$F_{k_2}(\cdot)$};
\node at (0,5) {$\oplus$};

\draw [-] (0,7.8) -- (0,7.2);
\draw [-] (0,7.2) -- (0,6.2);
\draw [-] (0.2,7) -- (2.5,7);
\draw [-] (6,7.8) -- (6,6.2);
\draw [-] (6,7) -- (3.5,7);

\draw [-] (0,5.8) -- (0,5.2);
\draw [-] (6,5.8) -- (6,4.2);
\draw [-] (0,4.8) -- (0,4.2);
\draw [-] (0.2,5) -- (2.5,5);
\draw [-] (6,5) -- (3.5,5);

\draw [-] (6,6.2) -- (0,5.8);
\draw [-] (0,6.2) -- (6,5.8);

\node at (3,3) {$\vdots$};

\draw [-] (6,1.2) -- (0,0.8);
\draw [-] (0,1.2) -- (6,0.8);

\node at (0,0) {$C_L$ ($n/2$ bits)};
\node at (6,0) {$C_R$ ($n/2$ bits)};
\end{tikzpicture}

With $r$ rounds.
\end{center}
$F:\bit^{n'}\times\bit^{n/2} \rightarrow \bit^{n/2}$ used a lot in practice, also a bit in provable constructions (RSA, OAEP).

Given $k_1,...,k_n$, $C=C_L||C_R$ we can recover $M=M_L||M_R$ (following the circuit from bottom to top).

DES (1977, designed by IBM/NSA) was the standard choice until the 2000s.

\Ex{}{}{With $n=64$, and key-size $n'=56$. We take $k\in\bit^{n'}$ each $k_i$ is a (simple ) function of $k$ and their size is $48$.
Take $F:\bit^{48}\times\bit^{32} \rightarrow \bit^{32}$ and $r=16$. For today, $2^{56}$ is not big enough to provide security. Broken by exhaustive search. In pratice we still use it within "Triple DES".}

\subsubsection{Rijndael/AES}
Competition by NIST.\\
Rijndael was chosen and its norm change to AES. The key size are $128,192,256$. the block size is n=128 and works with rounds $r=10,12,14$. but not base on Feistel networks.

\subsection{Formalisation : Pseudo Random Function (PRF)}
\subsubsection{Definition}
\Def{Pseudo Random Function}{def:PRF}{A pseudo random function is a deterministic function $F:\bit^t\times\bit^n\rightarrow\bit^m$ computable in poly time that satisfies the \underline{security requirement}:\\
it cannot be efficiently distinguished from a truly uniform function $f:\bit^n\rightarrow\bit^m$.}

\Rem We have $|\{f:\bit^n\rightarrow\bit^m\}|=(2^m)^{2^n}$ and $|\{F(k,\cdot)\}|=2^t$

We consider the two experiments $Exp_{Unif}$ and $Exp_F$ that are the equivalent for $F$ of the experiments where a challenger gives a random $x$ or $x=G(k)$ to an adversary of the PRG $G$ (it chooses a random function $f$ in $\bit^n\rightarrow\bit^m$). 

\begin{center}
\begin{tikzpicture}[>=latex]
\node	[]	at 	(0,6)	{Challenger};
\node	[]	at	(6,6)	{Adeversary};
\node	[]	at	(0,5.5)	{$b\hookrightarrow U(\{0,1\})$};
\node	[]	at	(0,5)	{$f\hookrightarrow U(\bit^n\rightarrow\bit^m)$};
\node 	[]	at	(0,4.5)	{$k\hookrightarrow U(\{0,1\}^t)$};
\node	[]	at	(0,1)	{Test if $b=b'$};

\draw	[->]	(5,4)	--node[above]	{$x_i$}		(1,4);

\node	[]	at	(0,3.5)	{if $b=0$ then $y_i=f(x_i)$};
\node	[] at	(0,3)	{else $y_i=F(k,x_i)$};
\draw	[->]	(1,2.5)	--node[above]	{$y_i$}	(5,2.5);
\draw	[->]	(5,1.5)	--node[above]	{$b'$}		(1,1.5);
\end{tikzpicture}
\end{center}

\Def{Security of a PRF}{def securePRF}{The PRF $F$ is said secure if for all PPT adversary $\A$ we have $Adv_\A(F)$ negligible.} 

It seems much stronger than a PRG, whixh only do one query on a uniformly chosen input where as many queries on adaptively chosen inputs.

\subsubsection{Equivalence between PRF and PRG.}
\Thm{Equivalence}{thm:equivPRGPRF}{There exists a secure PRG if and only if there exists a secure PRF.}

\begin{proof}
\begin{itemize}
\item Easy direction:
if we have a PRF $F:\bit^t\times\bit^n\rightarrow\bit^m$ then we build a PRG $G:\bit^t\rightarrow\bit^m$. Define $G(k)=F(k,0)$. If we need more bits, $G(k)=||_{i}F(k,i)$

The rest of this direction is given as an exercise.\\
\Rem We could have defined also $G(k||m)=F(k,r)$.
\item The less easy direction. Assume we have $G:\bit^n\rightarrow\bit^{2n}$ a PRG. Let us see first how to build PRF $F_1:\bit^n\times\bit\rightarrow\bit^n$.
We define $F_1(k,0)=G(k)_{|L}$ and $F_1(k,1)=G(k)_{|R}$.

We also define $F_2:\bit^n\times\bit^2\rightarrow\bit^n$. $F_2(k,(i,j))=F_1(F_1(k,i),j)$.

We use an hybrid argument. If the PRF adversary notices the difference between $Exp_F$  and the first hybrid it can be used to break the PRG. If the PRF adversary notices the diffrence between the 2 hybrid, we can break the PRG.
Idem between $Exp_{Unif}$ and the second hybrid.

$F_l:\bit^n\times\bit^l\rightarrow\bit^n$ described by the following algorithm\\
\begin{algorithme}
\underline{Inputs:} key $k$, $x$.\\
\ForFromTo{i}{0}{l}{$k_i::=\begin{array}{r l}
G(k_{i-1})_{|L} & \text{if $x_i=0$}\\
G(k_{i-1})_{|R} & \text{if $x_i=1$}\\
\end{array}$}
\Return $k_l$
\end{algorithme}
\end{itemize}
\end{proof}

\subsection{Encrypting with PRF}
\subsubsection{One message security}
What not to do ELB (Electronic Code Book) mode\\
$m=(m_1||...||m_t)$ with $m_i\in\bit^n$\\
$c=F_k(m_1)||...||F_k(m_t)$\\ 
It is not secure.

DETCTR (determinist Counter Mode)
$m=(m_1||...||m_t)$ with $m_i\in\bit^n$\\
$c=F_k(1)\oplus m_1||...||F_k(t)\oplus m_t$\\
This is sementically secure against 1 message attacks. The proof is almost identical to the one of the PRG construction (it's the one time pad).

\end{document}
